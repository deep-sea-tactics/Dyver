#ifndef H_THRUSTER
#define H_THRUSTER

#include <memory>
#include <vector>

#include <Eigen/Dense>

/**
 * @brief Abstract thruster; purely a mathematical object
 *
 */
class thruster_t
{
public:
	thruster_t(const Eigen::Vector3d pos, const Eigen::Vector3d look, const double force)
	{
		m_pos = pos;
		m_look = look;
		m_force = force;
	}

	/**
	 * @brief Get the position object
	 *
	 * @return Eigen::Vector3d& Position object in ROV space
	 */
	auto get_pos() -> Eigen::Vector3d & { return m_pos; }

	/**
	 * @brief Get the look direction object of this thruster.
	 *
	 * @return Eigen::Vector3d& The look direction of the thruster
	 */
	auto get_look() -> Eigen::Vector3d & { return m_look; }

	/**
	 * @brief Get the force
	 *
	 * @return double& Force value
	 */
	auto get_force() -> double & { return m_force; }

	/**
	 * @brief Get the throttle
	 *
	 * @return double& Throttle value
	 */
	auto get_throttle() -> double & { return m_throttle; }

	// If you're looking at this and making a confused face,
	// know that this quantity will have been linearized at this
	// point.

	/**
	 * @brief Returns the current output of the thruster
	 *
	 * @return double The amount of output generated by this thruster (newtons)
	 */
	auto get_output() -> double { return m_throttle * m_force; }

private:
	/**
	 * @brief Linearly scaled "maximum" force output of the thruster. In newtons.
	 *
	 */
	double m_force;

	double m_throttle;

	Eigen::Vector3d m_pos{Eigen::Vector3d(0, 0, 0)};
	Eigen::Vector3d m_look{Eigen::Vector3d(0, 0, 0)}; // Tada! Thrusters are very simple...
};

typedef std::vector<std::shared_ptr<thruster_t>> thrusters_t;

#endif